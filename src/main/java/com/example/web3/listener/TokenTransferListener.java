package com.example.web3.listener;

import com.example.web3.config.Web3jConfig;
import com.example.web3.entity.DepositRecord;
import com.example.web3.service.DepositService;
import io.reactivex.disposables.Disposable;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;
import org.web3j.abi.EventEncoder;
import org.web3j.abi.TypeReference;
import org.web3j.abi.datatypes.Address;
import org.web3j.abi.datatypes.Event;
import org.web3j.abi.datatypes.generated.Uint256;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.DefaultBlockParameterName;
import org.web3j.protocol.core.methods.request.EthFilter;
import org.web3j.protocol.core.methods.response.EthBlock;
import org.web3j.protocol.core.methods.response.Log;

import javax.annotation.PreDestroy;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.List;

/**
 * Transfer事件监听
 * @author jiangyuxuan
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class TokenTransferListener implements CommandLineRunner {

    private final Web3j web3j;
    private final Web3jConfig web3jConfig;
    private final DepositService depositService;

    private Disposable subscription;
    
    // 重试相关参数
    private static final int MAX_RETRY_ATTEMPTS = 5;
    private static final long INITIAL_RETRY_DELAY_MS = 5000; // 5秒
    private int retryCount = 0;

    private static final Event TRANSFER_EVENT = new Event("Transfer",
            Arrays.asList(
                    new TypeReference<Address>(true) {},
                    new TypeReference<Address>(true) {},
                    new TypeReference<Uint256>(false) {}
            ));

    private static final String TRANSFER_EVENT_SIGNATURE = EventEncoder.encode(TRANSFER_EVENT);

    // 代币的小数位数，从合约动态获取
    private int tokenDecimals = 18; // 默认值

    @Override
    public void run(String... args) {
        log.info("启动监听器...");
        // 先测试连接
        if (!testConnection()) {
            log.error("无法连接到 RPC 节点，请检查配置");
            return;
        }
        // 获取代币的 decimals
        fetchTokenDecimals();
        startListening();
    }
    
    /**
     * 测试 RPC 连接
     */
    private boolean testConnection() {
        try {
            log.info("测试 RPC 连接: {}", web3jConfig.getRpcUrl());
            String clientVersion = web3j.web3ClientVersion().send().getWeb3ClientVersion();
            log.info("连接成功，节点版本: {}", clientVersion);
            
            // 获取当前区块高度
            BigInteger blockNumber = web3j.ethBlockNumber().send().getBlockNumber();
            log.info("当前区块高度: {}", blockNumber);
            
            return true;
        } catch (Exception e) {
            log.error("连接测试失败: {}", e.getMessage(), e);
            return false;
        }
    }
    
    /**
     * 从合约获取 decimals
     */
    private void fetchTokenDecimals() {
        try {
            String contractAddress = web3jConfig.getToken().getContractAddress();
            
            // ERC20 decimals() 方法签名: 0x313ce567
            org.web3j.protocol.core.methods.request.Transaction transaction = 
                org.web3j.protocol.core.methods.request.Transaction.createEthCallTransaction(
                    null,
                    contractAddress,
                    "0x313ce567"  // decimals() 的方法签名
                );
            
            String result = web3j.ethCall(transaction, DefaultBlockParameterName.LATEST)
                    .send()
                    .getValue();
            
            // 解析返回值（uint8）
            if (result != null && !result.equals("0x")) {
                tokenDecimals = new BigInteger(result.substring(2), 16).intValue();
                log.info("从合约获取 decimals 成功: {} (合约: {})", tokenDecimals, contractAddress);
            } else {
                log.warn("无法从合约获取 decimals，使用默认值: {}", tokenDecimals);
            }
        } catch (Exception e) {
            log.error("获取 decimals 失败，使用默认值 {}: {}", tokenDecimals, e.getMessage());
        }
    }

    public void startListening() {
        try {
            String contractAddress = web3jConfig.getToken().getContractAddress();
            String contractName = web3jConfig.getToken().getContractName();
            Integer requiredConfirmations = web3jConfig.getToken().getConfirmations();

            log.info("开始监听 {} - {}", contractName, contractAddress);
            log.info("区块确认数要求: {} 个区块", requiredConfirmations);

            // 从最新区块开始监听
            // 确认数检查在 handleTransferEvent 中通过睡眠实现
            EthFilter filter = new EthFilter(
                    DefaultBlockParameterName.LATEST,
                    DefaultBlockParameterName.LATEST,
                    contractAddress
            );
            filter.addSingleTopic(TRANSFER_EVENT_SIGNATURE);

            subscription = web3j.ethLogFlowable(filter).subscribe(
                    this::handleTransferEvent,
                    error -> {
                        log.error("监听出错: {}", error.getMessage(), error);
                        handleError(error);
                    },
                    () -> log.info("监听流完成")
            );

            log.info("监听启动成功");
            retryCount = 0; // 重置重试计数

        } catch (Exception e) {
            log.error("启动失败: {}", e.getMessage(), e);
        }
    }

    /**
     * 日志格式 topics[0] = 事件签名
     * topics[1] = from 地址
     * topics[2] = to 地址
     * data      = value 金额
     * @param eventLog
     */
    private void handleTransferEvent(Log eventLog) {
        try {
            //为什么会有链重组？以太坊使用验证者来产生区块，可能因为网络延迟会产生分叉？
            // 先睡眠等待区块确认
            Integer requiredConfirmations = web3jConfig.getToken().getConfirmations();
            if (requiredConfirmations != null && requiredConfirmations > 0) {
                //每个区块等个20s 瞎几把估一个
                long sleepMs = requiredConfirmations * 20 * 1000L;
                log.info("交易 {} 等待 {} 秒以获得 {} 个区块确认", 
                        eventLog.getTransactionHash(), 
                        sleepMs / 1000, 
                        requiredConfirmations);
                Thread.sleep(sleepMs);
            }
            
            // 睡醒后再检查一次确认数
            if (!isConfirmed(eventLog)) {
                log.warn("交易 {} 等待后确认数仍不足，跳过处理", eventLog.getTransactionHash());
                return;
            }
            
            List<String> topics = eventLog.getTopics();
            //日志包含至少 3 个 topics,事件签名 + from + to
            if (topics.size() < 3) {
                log.error("topics数量不对: {}", topics.size());
                return;
            }

            String fromAddress = decodeAddress(topics.get(1));
            String toAddress = decodeAddress(topics.get(2));
            
            String data = eventLog.getData();
            BigInteger value = new BigInteger(data.substring(2), 16);
            //实际金额 = 原始值 / 10^decimals
            BigDecimal amountDecimal = new BigDecimal(value)
                    .divide(BigDecimal.TEN.pow(tokenDecimals));

            EthBlock.Block block = web3j.ethGetBlockByNumber(
                    org.web3j.protocol.core.DefaultBlockParameter.valueOf(
                            BigInteger.valueOf(eventLog.getBlockNumber().longValue())
                    ),
                    false
            ).send().getBlock();

            Long timestamp = block != null ? block.getTimestamp().longValue() : System.currentTimeMillis() / 1000;

            DepositRecord record = DepositRecord.builder()
                    .txHash(eventLog.getTransactionHash())
                    .blockNumber(eventLog.getBlockNumber().longValue())
                    .blockHash(eventLog.getBlockHash())
                    .contractAddress(eventLog.getAddress())
                    .fromAddress(fromAddress)
                    .toAddress(toAddress)
                    .amount(value.toString())
                    .amountDecimal(amountDecimal)
                    .decimals(tokenDecimals)
                    .logIndex(eventLog.getLogIndex().intValue())
                    .transactionIndex(eventLog.getTransactionIndex().intValue())
                    .timestamp(timestamp)
                    .build();

            log.info("Transfer事件 - tx: {}, from: {}, to: {}, amount: {}",
                    record.getTxHash(), record.getFromAddress(), 
                    record.getToAddress(), record.getAmountDecimal());

            depositService.saveDepositRecord(record);

        } catch (Exception e) {
            log.error("处理事件失败: {}", e.getMessage(), e);
        }
    }

    /**
     * 检查区块确认数是否足够
     * @param eventLog 事件日志
     * @return true = 确认数足够，可以处理；false = 确认数不足，暂不处理
     */
    private boolean isConfirmed(Log eventLog) {
        try {
            Integer requiredConfirmations = web3jConfig.getToken().getConfirmations();

            if (requiredConfirmations == null || requiredConfirmations == 0) {
                return true;
            }
            
            // 获取当前最新区块高度
            BigInteger latestBlockNumber = web3j.ethBlockNumber().send().getBlockNumber();
            
            // 事件所在区块高度
            BigInteger eventBlockNumber = eventLog.getBlockNumber();
            
            // 减去本次事件的区块高度，可以得到已确认的区块数
            BigInteger confirmations = latestBlockNumber.subtract(eventBlockNumber);
            
            boolean isConfirmed = confirmations.compareTo(BigInteger.valueOf(requiredConfirmations)) >= 0;
            
            if (!isConfirmed) {
                log.info("交易 {} 在区块 {}，当前区块 {}，确认数 {}/{}（不足）",
                        eventLog.getTransactionHash(),
                        eventBlockNumber,
                        latestBlockNumber,
                        confirmations,
                        requiredConfirmations);
            } else {
                log.info("交易 {} 确认数 {}，已达到要求的 {} 个确认",
                        eventLog.getTransactionHash(),
                        confirmations,
                        requiredConfirmations);
            }
            
            return isConfirmed;
            
        } catch (Exception e) {
            log.error("检查区块确认数失败: {}", e.getMessage(), e);
            // 出错时保守处理：不处理该事件
            return false;
        }
    }
    
    // topic格式: 0x000000000000000000000000{address}
    private String decodeAddress(String topic) {
        if (topic.length() < 66) {
            return topic;
        }
        return "0x" + topic.substring(26);
    }

    /**
     * 错误处理和重连机制
     */
    private void handleError(Throwable error) {
        if (retryCount >= MAX_RETRY_ATTEMPTS) {
            log.error("已达到最大重试次数 {}，停止重连", MAX_RETRY_ATTEMPTS);
            return;
        }
        
        retryCount++;
        long delayMs = INITIAL_RETRY_DELAY_MS * retryCount;
        log.warn("准备在 {} 毫秒后进行第 {} 次重连尝试", delayMs, retryCount);
        
        // 使用新线程延迟重连
        new Thread(() -> {
            try {
                Thread.sleep(delayMs);
                log.info("开始第 {} 次重连尝试", retryCount);
                
                // 先测试连接
                if (testConnection()) {
                    startListening();
                } else {
                    log.error("重连前测试失败，将继续重试");
                    handleError(error); // 递归重试
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                log.error("重连线程被中断", e);
            }
        }).start();
    }
    
    @PreDestroy
    public void stopListening() {
        if (subscription != null && !subscription.isDisposed()) {
            subscription.dispose();
            log.info("监听器已停止");
        }
    }
}

